package web

import (
	"os"
	"os/signal"
	"net/http"

	"github.com/gorilla/mux"
	"github.com/sirupsen/logrus"
	// "github.com/juju/errors"
	"github.com/jinzhu/gorm"

	"haproxy-certs/database"
)

var log = logrus.New()

func doError(w http.ResponseWriter, r *http.Request, err error) {
	if nil!=err {
		log.Errorf("Error on %s: %s", r.URL.String(), err.Error())
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}
}

func versionHandler(r *req) error {
	return r.Render("version.html", map[string]interface{}{"Version":"generated by GoT"})
}

func Web(conn string, listen string) error {
	return database.ConnectAndMigrate(conn, func(db *gorm.DB) error {
		r := mux.NewRouter()
		r.Handle("/version", handler(versionHandler))

		// depending on the build, this will come from vfs or from the local filesystem
		r.Handle("/{path:.*}", http.FileServer(Public))

		E := make(chan error)
		go func() {
			log.Infof("Starting webserver on %s", listen)
			if err := http.ListenAndServe(listen, r); nil!=err {
				E <- err
				return
			}
			E <- nil
		}()

		S := make(chan os.Signal)
		signal.Notify(S, os.Interrupt, os.Kill)
		select {
		case err := <- E:
			log.Error(err)
			return err
		case <- S:
			return nil
		}
	})
}